{
  "nav": {
    "medias": "MediasAPI",
    "finance": "FinanceAPI",
    "projects": "Todos os Projetos"
  },
  "home": {
    "title": "Gustavo Henrique | Desenvolvedor",
    "description1": "Atuo no desenvolvimento back-end construindo APIs, aplicações escaláveis e projetos estruturados com boas práticas de engenharia de software com Java e Spring. Trabalho com arquitetura limpa, princípios SOLID, padrões de projeto, versionamento de código, documentação técnica e testes automatizados. Tenho experiência em bancos de dados relacionais, estruturas de dados e algoritmos, aplicando soluções eficientes e de qualidade.",
    "description2": "Ao lado lhe apresento alguns projetos pessoais que resolvem problemas do meu dia a dia, as soluções foram elaboradas e documentadas visando seguir boas práticas e recursos do mercado de desenvolvimente de software.",
    "techTitle": "Tecnologias"
  },
  "allProjects": {
    "title": "Todos os Projetos"
  },
  "mediasAPI": {
    "menu": {
      "apresentacao": "Apresentação",
      "motivacao": "Motivação e Solução",
      "funcionalidades": "Principais Funcionalidades",
      "utilizandoApi": "Utilizando a API",
      "praticas": "Práticas Adotadas"
    },
    "title": "API Rest de Gestão de Notas e Projeções Acadêmicas",
    "placeholder": "AQUI",
    "apresentacao": {
      "title": "Apresentação",
      "docLink": "Documentação técnica",
      "p1": "Uma plataforma inteligente de gestão acadêmica que transforma a maneira como estudantes e professores lidam com avaliações. A solução oferece armazenamento centralizado de notas, cálculo automático de médias e, principalmente, projeções estratégicas que permitem aos usuários simular cenários e planejar seu desempenho com antecedência.",
      "p2": "O diferencial está na flexibilidade: cada disciplina pode ter seu próprio método de cálculo personalizado através de expressões matemáticas customizáveis. O sistema processa essas expressões dinamicamente, identifica variáveis e constantes através de regex, e aplica o algoritmo Shunting Yard com notação polonesa reversa (RPN) para garantir a precedência correta dos operadores — tudo isso sem comprometer a performance ou usabilidade.",
      "p3": "Desenvolvida seguindo princípios SOLID e arquitetura em camadas, a API combina validações robustas (Bean Validation), autenticação JWT, testes automatizados com mocks e documentação OpenAPI 3. A solução foi containerizada com Docker e utiliza Spring Data JPA para consultas otimizadas, demonstrando uma implementação backend completa e profissional."
    },
    "motivacao": {
      "title": "Motivação e Solução",
      "p1": "Durante a jornada acadêmica na universidade, gerenciar as notas ou até mesmo apenas armazená-las é um processo que pode ser automatizado de maneira eficiente. No entanto, como cada professor e disciplina definem seus próprios métodos de avaliação e critérios de desempenho de acordo com suas preferências e abordagens, há uma grande variabilidade e flexibilidade nesse processo.",
      "p2": "Para que a aplicação possa suportar essas definições personalizadas, foi implementada uma solução baseada no processamento de expressões regulares, permitindo a identificação e manipulação dinâmica de variáveis, constantes e operadores. Dessa forma, o cálculo das médias finais é automatizado de maneira flexível e adaptável a diferentes regras de avaliação.",
      "p3": "Outro desafio foi a implementação desse cálculo dinâmico. A solução adotada utiliza a notação polonesa inversa (RPN), que elimina a necessidade de parênteses ao definir a ordem correta de precedência diretamente em sua estrutura. Além disso, foi empregada uma adaptação do algoritmo Shunting Yard, utilizando pilhas e listas como estruturas de dados para garantir a correta avaliação das expressões."
    },
    "funcionalidades": {
      "title": "Principais Funcionalidades",
      "items": [
        "Armazene notas de forma estruturada e eficiente.",
        "Defina métodos personalizados para cálculo de médias.",
        "Obtenha automaticamente a pontuação necessária para alcançar metas acadêmicas.",
        "Simule diferentes cenários para planejamento estratégico.",
        "Gerencie disciplinas."
      ]
    },
    "utilizandoApi": {
      "title": "Utilizando a API",
      "login": {
        "title": "Login:",
        "item": "O usuário cria seu perfil se cadastrando no sistema."
      },
      "autenticacao": {
        "title": "Autenticação:",
        "item": "A API valida as credenciais e, se bem-sucedida, retorna um token JWT."
      },
      "disciplinas": {
        "title": "Disciplinas:",
        "item": "O usuário pode criar e editar suas disciplinas personalizadas."
      },
      "projecoes": {
        "title": "Projeções:",
        "item": "Uma projeção é criada automaticamente na definição do método de cálculo no passo anterior. Usuários podem criar, editar e visualizar outras projeções."
      },
      "avaliacoes": {
        "title": "Avaliações:",
        "item": "Também criadas automaticamente a cada projeção. Usuários podem lançar notas."
      }
    },
    "praticas": {
      "title": "Práticas Adotadas",
      "arquitetura": {
        "title": "Arquitetura e Design",
        "items": [
          "API REST com divisão em camadas",
          "Aplicação dos princípios SOLID",
          "Injeção de Dependências",
          "Uso do padrão Data Transfer Object (DTO)"
        ]
      },
      "validacao": {
        "title": "Validação e Segurança",
        "items": [
          "Validações personalizadas e uso do Bean Validation",
          "Implementação de autenticação e autorização via JWT"
        ]
      },
      "erros": {
        "title": "Tratamento de Erros e Respostas",
        "items": [
          "Captura e tratamento de erros padronizados"
        ]
      },
      "documentacao": {
        "title": "Documentação",
        "items": [
          "Documentação da API com diagramas e exemplos",
          "Documentação técnica dos endpoints com OpenAPI 3"
        ]
      },
      "testes": {
        "title": "Testes e Qualidade de Código",
        "items": [
          "Testes automatizados com criação de mocks e ambiente separado"
        ]
      },
      "banco": {
        "title": "Banco de Dados",
        "items": [
          "Modelagem do banco de dados relacional com definições de constraints",
          "Consultas JPQL e SQL nativo com Spring Data JPA"
        ]
      },
      "ferramentas": {
        "title": "Ferramentas e Deploy",
        "items": [
          "Uso de API Client e Database Client durante o desenvolvimento",
          "Encapsulamento da aplicação com Docker, criando imagens e containers personalizados",
          "Versionamento de código com Git"
        ]
      },
      "tecnologias": {
        "title": "Tecnologias"
      }
    }
  },
  "financeAPI": {
    "menu": {
      "apresentacao": "Apresentação",
      "motivacao": "Motivação e Solução",
      "funcionalidades": "Principais Funcionalidades",
      "utilizandoApi": "Utilizando a API",
      "praticas": "Práticas Adotadas"
    },
    "title": "API GraphQL de Integração Bancária, Análise e Classificação de Transações",
    "placeholder": "AQUI",
    "apresentacao": {
      "title": "Apresentação",
      "docLink": "Documentação técnica",
      "p1": "Uma API GraphQL completa para gestão financeira inteligente que conecta o ecossistema Open Finance ao usuário final. A plataforma captura automaticamente transações bancárias via webhooks, organiza movimentações em categorias personalizadas e oferece análises detalhadas com cálculo automático de saldo — tudo através de consultas GraphQL flexíveis e precisas.",
      "p2": "O sistema foi projetado para resolver um problema real: a dificuldade de consolidar e categorizar movimentações financeiras de múltiplas contas. Através da integração com o agregador Pluggy em ambiente sandbox, a API simula o comportamento de uma instituição participante do Open Finance, processando webhooks em tempo real e persistindo dados com relacionamentos complexos em PostgreSQL.",
      "p3": "A arquitetura implementa mensageria com Kafka para processamento assíncrono, Spring Security com autenticação X-API-KEY, e utiliza GraphQL para proporcionar aos clientes (dashboards, apps mobile, integrações) a flexibilidade de requisitar exatamente os dados necessários. O projeto demonstra conhecimento profundo em integração de APIs externas, processamento de eventos em tempo real e design de APIs modernas orientadas a GraphQL."
    },
    "motivacao": {
      "title": "Motivação e Solução",
      "p1": "A intenção inicial era construir um sistema integrado e funcional capaz de processar automaticamente as movimentações financeiras. Acontece que obter, classificar e analisar transações bancárias em tempo real é um processo que demanda alto nível de integração com instituições financeiras. No entando, o acesso direto a dados bancários reais exige a habilitação como instituição autorizada no Open Finance. Para seguir com o propósito, foi implementada uma solução utilizando um agregador de dados financeiros que oferece um ambiente sandbox, simulando o comportamento de uma instituição participante do Open Finance. Assim, foi possível simular webhooks, testando cenários reais sem depender de dados sensíveis.",
      "p2": "Outro ponto relevante foi a escolha do GraphQL, que possibilita consultas flexíveis e precisas, retornando apenas os dados realmente necessários para cada cliente ou integração. Isso facilita a construção de dashboards dinâmicos e aplicações front-end, bem como a análise pessoal.",
      "p3": "Além disso, a API permite a categorização inteligente de transações, possibilitando ao usuário final ou à aplicação selecionar apenas os lançamentos relevantes e calcular automaticamente o saldo para análise, filtragem ou integração com relatórios financeiros personalizados."
    },
    "funcionalidades": {
      "title": "Principais Funcionalidades",
      "items": [
        "Receber transações de forma automática via webhook Pluggy.",
        "Persistir transações em banco de dados relacional.",
        "Classificar por categorias personalizadas.",
        "Consultar histórico de transações.",
        "Visualizar transações de acordo com filtros- por categoria,por período e por tipo.",
        "Cálculo automático do saldo de acordo com as transações selecionadas."
      ]
    },
    "utilizandoApi": {
      "title": "Utilizando a API",
      "users": {
        "title": "Users:",
        "item": "O usuário cria seu perfil se cadastrando no sistema."
      },
      "accounts": {
        "title": "Accounts:",
        "item": "o usuário pode criar e editar suas contas, ainda sem conexão com o agregador."
      },
      "integration": {
        "title": "FinancialIntegration:",
        "item": "Com a conta criada é possível conectá-la com uma instituição financeira."
      },
      "category": {
        "title": "Category:",
        "item": "Usuários criam e gerenciam suas próprias categorias e subcategorias que poderão ser atribuídas à transações"
      },
      "transactions": {
        "title": "Transactions:",
        "item": "Armazene e selecione as transações desejadas calculando automaticamente o saldo."
      }
    },
    "praticas": {
      "title": "Práticas Adotadas",
      "arquitetura": {
        "title": "Arquitetura e Design",
        "items": [
          "API GraphQL com divisão em camadas",
          "Aplicação dos princípios SOLID",
          "Injeção de Dependências",
          "Uso do padrão Data Transfer Object (DTO)",
          "Uso de ferramenta de Tuneamento (Ngrok)",
          "Integração com modelo de dados de API externas (Pluggy)",
          "Mensageria com Kafka",
          "Armazenamento de credenciais em arquivos"
        ]
      },
      "validacao": {
        "title": "Validação e Segurança",
        "items": [
          "Validações personalizadas e uso do Bean Validation",
          "Implementação de autenticação por meio de X-API-KEY"
        ]
      },
      "erros": {
        "title": "Tratamento de Erros e Respostas",
        "items": [
          "Captura e tratamento de erros padronizados"
        ]
      },
      "documentacao": {
        "title": "Documentação",
        "items": [
          "Documentação da API com diagramas e exemplos",
          "Documentação técnica dos endpoints com GraphiQL"
        ]
      },
      "testes": {
        "title": "Testes e Qualidade de Código",
        "items": [
          "Testes automatizados com criação de mocks e ambiente separado"
        ]
      },
      "banco": {
        "title": "Banco de Dados",
        "items": [
          "Modelagem do banco de dados relacional com definições de constraints",
          "Consultas JPQL e SQL nativo com Spring Data JPA"
        ]
      },
      "ferramentas": {
        "title": "Ferramentas e Deploy",
        "items": [
          "Uso de API Client, Database Client e Ambiente Sandbox durante o desenvolvimento",
          "Encapsulamento da aplicação com Docker, criando imagens e containers personalizados",
          "Versionamento de código com Git"
        ]
      },
      "tecnologias": {
        "title": "Tecnologias"
      }
    }
  },
  "projects": {
    "tiobolas": {
      "title": "Tio Bolas",
      "description": "Projeto desenvolvido em equipe, implementando conceitos como, TAD, manipulação de arquivos, Busca binária e estruturas de dados (fila)."
    },
    "hashtable": {
      "title": "HashTable",
      "description": "Projeto desenvolvido para aplicar o conteúdo da disciplina de estruturas de dados 2, implementando tabela e função hash e operações sobre ela."
    },
    "agenda": {
      "title": "AgendaToDO",
      "description": "API para gerenciar tarefas (CRUD) que faz parte do desafio do Simplify para pessoas desenvolvedoras backend júnior."
    },
    "codinome": {
      "title": "CodinomeUol",
      "description": "aplicação Java capaz de recuperar informações de um arquivo XML e de um arquivo JSON, persistir um cadastro em um banco de dados em memória ou em arquivo e listar os cadastros em uma interface simples."
    },
    "wallet": {
      "title": "SimplifiedWallet",
      "description": "Sistema de pagamentos simplificada. Nela é possível depositar e realizar transferências de dinheiro entre usuários. Temos 2 tipos de usuários, os comuns e lojistas, ambos têm carteira com dinheiro e realizam transferências entre eles."
    },
    "dotnetFinance": {
      "title": ".FinanceAPI",
      "description": "Versão REST da API de Processamento de transações bancárias baseada em Open Finance, desenvolvida em .Net"
    },
    "dotnetMedias": {
      "title": ".MediasAPI",
      "description": "Projeto Medias API : Gestão de médias e Projeção de notas acadêmicas. Escrito em duas outras stacks - .Net e NodeJS",
      "linkLabel": ".Net",
      "additionalLabel": "NodeJS"
    }
  }
}
